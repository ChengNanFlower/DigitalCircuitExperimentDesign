`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Design Name: 4-bit Carry-Lookahead Adder
// Module Name: CLA_4bit
// Description: 本模块使用超前进位逻辑实现一个4位加法器。
//              1. 它首先计算进位生成(G)和进位传递(P)信号。
//              2. 然后使用数据流描述实现超前进位逻辑，并行计算所有进位。
//              3. 最后例化4个FA_gate模块，根据计算出的进位生成最终的和。
//
// Dependencies: FA_gate.v
//////////////////////////////////////////////////////////////////////////////////

module CLA_4bit(
    // 输出端口
    output [3:0] F,       // 4位加法和的输出
    output       C_out,   // 最终的进位输出 (即 C4)
    // 输入端口
    input  [3:0] A,       // 4位加数A
    input  [3:0] B,       // 4位加数B
    input        C_in     // 初始的进位输入 (即 C0)
    );

    // -- 步骤1: 定义进位生成(G)和进位传递(P)信号 --
    // 根据公式 G_i = A_i & B_i, P_i = A_i | B_i (或 A_i ^ B_i)
    // 这里我们使用标准的 P_i = A_i ^ B_i，因为它也用于最终求和
    wire [3:0] G; // 进位生成信号 Generate
    wire [3:0] P; // 进位传递信号 Propagate

    assign G = A & B;
    assign P = A ^ B; // 使用异或更标准，也便于求和

    // -- 步骤2: 定义并实现超前进位逻辑 (数据流描述) --
    // 定义连接超前进位逻辑单元与FA单元的进位线
    wire C0, C1, C2, C3;
    
    assign C0 = C_in; // C0就是初始输入进位

    // 根据实验指导书公式(5.4)展开
    // C1 = G0 + P0*C0
    assign C1 = G[0] | (P[0] & C0);
    
    // C2 = G1 + P1*G0 + P1*P0*C0
    assign C2 = G[1] | (P[1] & G[0]) | (P[1] & P[0] & C0);

    // C3 = G2 + P2*G1 + P2*P1*G0 + P2*P1*P0*C0
    assign C3 = G[2] | (P[2] & G[1]) | (P[2] & P[1] & G[0]) | (P[2] & P[1] & P[0] & C0);

    // C4 = G3 + P3*G2 + P3*P2*G1 + P3*P2*P1*G0 + P3*P2*P1*P0*C0
    assign C_out = G[3] | (P[3] & G[2]) | (P[3] & P[2] & G[1]) | (P[3] & P[2] & P[1] & G[0]) | (P[3] & P[2] & P[1] & P[0] & C0);


    // -- 步骤3: 例化四个FA_gate模块，计算最终的和 F --
    // 注意：这里的FA模块仅用于计算和(F)，其自身的进位输出(Ci_plus_1)被忽略。
    // 我们将超前进位逻辑计算出的C0, C1, C2, C3作为每个FA的进位输入。

    // 例化第0位全加器
    FA_gate FA0 (
        .Fi(F[0]), 
        .Ci_plus_1(), // 忽略FA自带的进位输出
        .Ai(A[0]), 
        .Bi(B[0]), 
        .Ci(C0)       // 使用超前进位C0
    );

    // 例化第1位全加器
    FA_gate FA1 (
        .Fi(F[1]), 
        .Ci_plus_1(), // 忽略FA自带的进位输出
        .Ai(A[1]), 
        .Bi(B[1]), 
        .Ci(C1)       // 使用超前进位C1
    );

    // 例化第2位全加器
    FA_gate FA2 (
        .Fi(F[2]), 
        .Ci_plus_1(), // 忽略FA自带的进位输出
        .Ai(A[2]), 
        .Bi(B[2]), 
        .Ci(C2)       // 使用超前进位C2
    );

    // 例化第3位全加器
    FA_gate FA3 (
        .Fi(F[3]), 
        .Ci_plus_1(), // 忽略FA自带的进位输出
        .Ai(A[3]), 
        .Bi(B[3]), 
        .Ci(C3)       // 使用超前进位C3
    );
    
endmodule
